#include <random> // used to produce a random number
#include <vector>// dynamic array container
#include <string> //string operations
#include <iostream> // Input output operations
#include <map> //will be used here to search our matrix using strings instead of numbers. Most useful for user input

using namespace std;//makes it to where I dont have to type std::cout just cout

//Intializing

//variables
int currentWeather{};//change this number to change intial weather state
int currentSeason{};//change this number to change intial season
int currentDay{0};
int monthManager{0};
int seasonLength{}; //change this number to change how long seasons last
bool ynContinue{};

//random system
std::random_device spark; // requests random data from the hardware (CPU voltage, keystrokes, etc), increases "randomness"
std::mt19937_64 randomEngine(spark()); //the actual random generator using 64 mersenne twister from 2000

//Seasonal map
//seasons = prefix,(map.std(std.string,int)); C# defaults to string if no third argument
std::map<std::string,int>Season = 
{ {"spring",0},{"summer",1},{"fall",2},{"winter",3}};

//Seasonal matrices
//{SUNNY,CLOUDY,RAINY} SUNNY
//{SUNNY,CLOUDY,RAINY} CLOUDY
//{SUNNY,CLOUDY,RAINY} RAINY

double probabilityMatrix[4][3][3] =
{
{{},{},{}}, //spring, mix rain favor
{{},{},{}},//summer, rain favor
{{},{},{}},//fall, mix cloudy favor
{{},{},{}}//winter, cloudy favor
};


int GetAdjacent(int CurrentSeason, int Direction) //Lerp helper function
{
    //1 is forwards -1 is backwards
    return (CurrentSeason + Direction - 4) % 4; //modulus makes sure it is always less than 4
}

void LinearInterpolator(int CurrentSeason, int SeasonLength, int MonthManager) // Linearly interpolates between seasons use the SeasonLength as a reference point
{
    //using SeasonLength as a weight reference, take the closest season (rounded down or up based on the center of the seasonlength) 
    //and create basically an average between the two seasons probabilities. The closer the middle of a season is, the heavier its 
    //probabilities weigh in the calculation.
}

void SeasonManager (int SeasonLength,int &CurrentSeason, int &MonthManager, int &CurrentDay) 
//& are references to the actual variable, in C++ the variables are function independant 
{
    if(MonthManager > SeasonLength) //if the season is over, reset the counter and move to the next season
    {
        CurrentSeason += 1;
        MonthManager = 0;
        if(CurrentSeason > 3) // if its outside the array (winter) reset to spring
        {
            CurrentSeason = 0;
        }
    }
    MonthManager += 1; //add day to season
    CurrentDay += 1;//add to overall day count
}

void MarkovsFunction(int &CurrentWeather,int &CurrentSeason,int &MonthManager,int &SeasonLength, int &CurrentDay)
{
   SeasonManager(SeasonLength,CurrentSeason,MonthManager,CurrentDay);
   LinearInterpolator(SeasonLength,CurrentSeason,MonthManager);
}

void main()
{
 
}
