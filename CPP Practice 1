#include <random> // used to produce a random number
#include <vector>// dynamic array container
#include <string> //string operations
#include <iostream> // Input output operations
#include <map> //will be used here to search our matrix using strings instead of numbers. Most useful for user input
#include <iterator> //for size()

using namespace std;//makes it to where I dont have to type std::cout just cout

//Intializing

//variables
int currentWeather{1};//change this number to change intial weather state
int currentSeason{1};//change this number to change intial season
int currentDay{1};
int monthManager{0};
int seasonLength{30}; //change this number to change how long seasons last
bool ynContinue{};

//random system
std::random_device spark; // requests random data from the hardware (CPU voltage, keystrokes, etc), increases "randomness", VERY INTENSIVE keep outside of loop or static
std::mt19937_64 randomEngine(spark()); //the actual random generator using 64-bit mersenne twister from year 2000
std::uniform_real_distribution <double> randomN(0.0,1.0); //actually creates the random number

//string to int maps
std::map <std::string,int> SeasonI = 
{ 
    {"spring", 0},
    {"summer", 1},
    {"fall",   2},
    {"winter", 3}
};

std::map <std::string,int> WeatherI = 
{ 
    {"sunny", 0},
    {"cloudy",1},
    {"rainy", 2}
};

//used for int to string
std::map<int, std::string> SeasonO = { 
    {0, "spring"}, 
    {1, "summer"}, 
    {2, "fall"}, 
    {3, "winter"} 
};

std::map<int, std::string> WeatherO = { 
    {0, "sunny"}, 
    {1, "cloudy"}, 
    {2, "rainy"} 
};

//Seasonal matrices
//{SUNNY,CLOUDY,RAINY} SUNNY
//{SUNNY,CLOUDY,RAINY} CLOUDY
//{SUNNY,CLOUDY,RAINY} RAINY

double probabilityMatrix[4][3][3] =
{
{{},{},{}}, //spring, mix rain favor
{{},{},{}},//summer, rain favor
{{},{},{}},//fall, mix cloudy favor
{{},{},{}}//winter, cloudy favor
};

//{SUNNY,CLOUDY,RAINY}
double interpolatedMatrix[3][3] =
{
{0,0,0},
{0,0,0},
{0,0,0}
};

//==========================================================================================

//completed
int GetAdjacent(int CurrentSeason, int Direction) //Lerp helper function
{
    //1 is forwards -1 is backwards
    return (CurrentSeason + Direction + 4) % 4; //modulus makes sure it is always less than 4
}

//completed
void LinearInterpolator(int CurrentSeason, int SeasonLength, int MonthManager) // Linearly interpolates between seasons use the SeasonLength as a reference point
{
    //three possbilities, Previous -> current, true (one day), and current -> next
    double midpoint = SeasonLength / 2.0;
    double ap; //the heart of the "percentage" blend between seasons, adjacent percentage
    int adjacent;

    if(MonthManager < midpoint) //First half
    {
        adjacent = GetAdjacent(CurrentSeason,-1); //get previous season
        ap = (static_cast<double>(MonthManager))/midpoint; //converts to double to avoid error, divide by midpoint to get a number between 0-1
    }

    else if (MonthManager > midpoint) //second half
    {
        adjacent = GetAdjacent(CurrentSeason,1); //get post season
        ap = (static_cast<double>(MonthManager) - midpoint)/midpoint; 
    }

    else
    {
        ap = 0.0; //"true" season
        adjacent = CurrentSeason; //prevents errors during true day, otherwise mathmatically would end up nullifying it instead
    }

    double p = 1.0 - ap; //percentage

    //sizeof returns BYTES not number of ELEMENTS, so divide by the next one down to determine actual number of elements. Wont work for non-uniform matrices
    int ROWS = sizeof(probabilityMatrix[0])/sizeof(probabilityMatrix[0][0]);
    int COLUMNS =  sizeof(probabilityMatrix[0][0])/sizeof(probabilityMatrix[0][0][0]);
    //This is scalable, the original matrix just needs to be tweaked for scalabilitya
    
    //iterate through our matrix and weigh values and fill in accordingly
    for (int r = 0; r < ROWS;r++)
    {
        for (int c = 0; c < COLUMNS;c++)
        {
            interpolatedMatrix[r][c] = (probabilityMatrix[CurrentSeason][r][c] * p) + (probabilityMatrix[adjacent][r][c] * ap);
        }
    }
    
 }

//completed
void SeasonManager (int SeasonLength,int &CurrentSeason, int &MonthManager, int &CurrentDay) //completed
//& are references to the actual variable, in C++ the variables are function independant 
{
    if(MonthManager > SeasonLength) //if the season is over, reset the counter and move to the next season
    {
        CurrentSeason += 1;
        MonthManager = 0;
        if(CurrentSeason > 3) // if its outside the array (winter) reset to spring
        {
            CurrentSeason = 0;
        }
    }
    MonthManager += 1; //add day to season
    CurrentDay += 1;//add to overall day count
}

void MarkovsFunction(int &CurrentWeather,int &CurrentSeason,int &MonthManager,int &SeasonLength, int &CurrentDay)//the bread and butter
{
    int tommorowWeather;
    SeasonManager(SeasonLength,CurrentSeason,MonthManager,CurrentDay); //manage season first
    LinearInterpolator(SeasonLength,CurrentSeason,MonthManager); //then linearly interpolate
    double dice = randomN(randomEngine); //calling our number generator, NOT resetting our spark

 
     for (int j = 0; j < (sizeof(interpolatedMatrix[CurrentWeather])/sizeof(interpolatedMatrix[CurrentWeather][j])); j++) //columns
     {
        if (dice <= interpolatedMatrix[CurrentWeather][j])
        {
            tommorowWeather = interpolatedMatrix[CurrentWeather][j];
        }
     }
    
    CurrentWeather = tommorowWeather;
}

//completed
int ConvertInput(int Type, string Key) //user input to numbers, easier of the two
{
    
    if (Type == 1) //seasons
    {
        auto result = SeasonI.find(Key); //uses auto to avoid excessive code involved with maps
        return result->second; //return second value, aka number
    }

    if (Type == 2) //weather
    {
        auto result = WeatherI.find(Key); //same thing just for weather
        return result->second; 
    }
}

//completed
string ConvertOutput(int Type, int Key)// numbers to text
{
    if (Type == 1) //seasons
    {
        auto result = SeasonO.find(Key); //same thing just for weather
        return result->second; 
    }

    if (Type == 2) //weather
    {
         auto result = WeatherO.find(Key); //same thing just for weather
        return result->second; 
    }
} 

//==========================================================================================

void main()
{
    cout << "Welcome to Justin's Weather system! \n I created this system in C++ using Markovs Chain theory to simuluate realistic weather patterns \n How many days would you like to simulate?";

    //determine user inputs
    int loop;
    cin >> loop;

    //converts input to numbers for the system
    string inputSeason;
    cout << "\nWhat is the current season?";
    cin >> inputSeason;
    currentSeason = ConvertInput(1,inputSeason);

    string inputWeather;
    cout << "\nWhat is todays weather??";
    cin >> inputWeather;
    currentWeather = ConvertInput(2,inputWeather);
    
    //the heart of the system loop
    for (int i = 1; i <= loop; i++)
    {
        //print each days' information
        cout << "Day " << i << "of "<<currentSeason<<": ";
        cout << ConvertOutput(2,currentWeather);

        MarkovsFunction(currentWeather,currentSeason,monthManager,seasonLength,currentDay); 
    }
}
